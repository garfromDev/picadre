#!/bin/bash
# generated by claude sonnet 4.5

# Script de redimensionnement automatique des images
# Réduit les images > 1920x1200 tout en préservant le ratio d'aspect
# Date: $(date +%Y-%m-%d)

# Configuration
PICTURES_DIR="$HOME/Pictures"
MAX_WIDTH=1920
MAX_HEIGHT=1200
LOG_FILE="$HOME/tmp/resize_images.log"
BACKUP_DIR="$HOME/Pictures_original_backup"

# Créer le dossier de backup s'il n'existe pas (première exécution)
if [ ! -d "$BACKUP_DIR" ]; then
    mkdir -p "$BACKUP_DIR"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - Dossier de backup créé: $BACKUP_DIR" >> "$LOG_FILE"
fi

# Vérifier que ImageMagick est installé
if ! command -v identify &> /dev/null || ! command -v mogrify &> /dev/null; then
    echo "$(date '+%Y-%m-%d %H:%M:%S') - ERREUR: ImageMagick n'est pas installé" >> "$LOG_FILE"
    echo "Installez-le avec: sudo apt install imagemagick"
    exit 1
fi

# Compteurs
total_checked=0
total_resized=0
total_errors=0

echo "$(date '+%Y-%m-%d %H:%M:%S') - Début du scan dans $PICTURES_DIR" >> "$LOG_FILE"

# Parcourir tous les fichiers images
find "$PICTURES_DIR" -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.gif" -o -iname "*.bmp" \) | while read -r image; do
    total_checked=$((total_checked + 1))
    
    # Obtenir les dimensions de l'image
    dimensions=$(identify -format "%w %h" "$image" 2>/dev/null)
    
    if [ $? -ne 0 ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') - Erreur lecture: $image" >> "$LOG_FILE"
        total_errors=$((total_errors + 1))
        continue
    fi
    
    width=$(echo "$dimensions" | awk '{print $1}')
    height=$(echo "$dimensions" | awk '{print $2}')
    
    # Vérifier si l'image dépasse les dimensions maximales
    if [ "$width" -gt "$MAX_WIDTH" ] || [ "$height" -gt "$MAX_HEIGHT" ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') - Redimensionnement: $image (${width}x${height})" >> "$LOG_FILE"
        
        # Créer une copie de backup (seulement si elle n'existe pas déjà)
        filename=$(basename "$image")
        backup_path="$BACKUP_DIR/$filename"
        
        if [ ! -f "$backup_path" ]; then
            cp "$image" "$backup_path"
        fi
        
        # Redimensionner l'image (conserve le ratio, ne dépasse pas 1920x1200)
        mogrify -auto-orient -resize "${MAX_WIDTH}x${MAX_HEIGHT}>" -quality 85 "$image" 2>/dev/null
        
        if [ $? -eq 0 ]; then
            # Vérifier les nouvelles dimensions
            new_dimensions=$(identify -format "%w %h" "$image" 2>/dev/null)
            echo "$(date '+%Y-%m-%d %H:%M:%S') - ✓ Succès: $new_dimensions" >> "$LOG_FILE"
            total_resized=$((total_resized + 1))
        else
            echo "$(date '+%Y-%m-%d %H:%M:%S') - ✗ Échec redimensionnement: $image" >> "$LOG_FILE"
            total_errors=$((total_errors + 1))
            # Restaurer depuis le backup en cas d'erreur
            if [ -f "$backup_path" ]; then
                cp "$backup_path" "$image"
            fi
        fi
    fi
done

# Résumé dans le log
echo "$(date '+%Y-%m-%d %H:%M:%S') - Scan terminé" >> "$LOG_FILE"
echo "Images vérifiées: $total_checked | Redimensionnées: $total_resized | Erreurs: $total_errors" >> "$LOG_FILE"
echo "----------------------------------------" >> "$LOG_FILE"

# Afficher un résumé dans le terminal si exécuté manuellement
if [ -t 1 ]; then
    echo "✓ Scan terminé"
    echo "Images vérifiées: $total_checked"
    echo "Images redimensionnées: $total_resized"
    echo "Erreurs: $total_errors"
    echo "Log: $LOG_FILE"
fi

exit 0
